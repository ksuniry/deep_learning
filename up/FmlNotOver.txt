package com.mvc.fml;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.cont.VerifyCont;
import com.mvc.dao.FmlDao;
import com.util.CmmUtil;

@Service
public class FmlNotOver {
	
	@Autowired
	Fml fml;
	@Autowired
	FmlDao fmlDao;
	
	private static Logger logger = Logger.getLogger(FmlNotOver.class.getName());
	
	public Map<String,Object> notOver(Map<String,Object> fmlInfoMap,List<Map<String, Object>> selAllWinList) {
		Map<String,Object> rtnInfo = new HashMap<String,Object>();
		String fml_cd = String.valueOf(fmlInfoMap.get("fml_cd"));
		try {
				
				String fml_group = String.valueOf(fmlInfoMap.get("fml_group"));
				String fml_judg = String.valueOf(fmlInfoMap.get("fml_judg"));
				int check_max_chapter = Integer.parseInt(String.valueOf(fmlInfoMap.get("check_chapter")));
				check_max_chapter = check_max_chapter == 0 ? 1 : check_max_chapter;
				int all_win_size = 0;
				int rang_cnt = Integer.parseInt(String.valueOf(fmlInfoMap.get("rang_cnt")));
				int inc_cnt = Integer.parseInt(String.valueOf(fmlInfoMap.get("inc_cnt")));
				
				Map<String,Object> chkMap = null;
				Map<String,Object> winnerMap = null;
				Map<String,Object> newFmlMap = new HashMap<String,Object>();
				int[] chkArray = null;
				int[] selAllWinArray = null;
				int notOverCnt = 0;
				boolean bln_insNewChapter = false;
				// winner_chapter 한칸 전까지
				// inc_cnt 낮음에서 높음으로
				newFmlMap.putAll(fmlInfoMap);
				newFmlMap.put("fml_cd", fml_group+"_"+fml_judg+"_"+rang_cnt+"_"+(inc_cnt+1));
				newFmlMap.put("inc_cnt", inc_cnt+1);
				
				//새로운 내용 있는지 확인 
				
				if(fmlDao.selNewFml(newFmlMap) == null  //기존에 내용이 없어야 하며
						&& Integer.parseInt(String.valueOf(newFmlMap.get("inc_cnt"))) < 7 //포함은 6개이상 될수가 없고 
						&& Integer.parseInt(String.valueOf(newFmlMap.get("inc_cnt"))) <= Integer.parseInt(String.valueOf(newFmlMap.get("rang_cnt"))) //포함 숫자는 기본 범위를 넘을 수 없다 
						) {
					bln_insNewChapter = true;
				}
				
				//fmlInfoMap.get("fml_tbl") 이 from 절에 table 됨 stair
				fmlInfoMap.put("stair_cd",fml_group);
				//WHERE  	CHAPTER >= #{check_chapter} AND		STAIR_CD = #{stair_cd}
				List<Map<String,Object>> chkList =  fmlDao.selFmlStairInfoList(fmlInfoMap);
				int chk_idx = 0;
				// 계단식 마지막은 이번에 도전해야하는 자료..
				all_win_size = selAllWinList.size();
				for(int i = check_max_chapter ; i < all_win_size ; i++) {// winner_chapter 한칸 전까지 why....stair 나온걸로 다음 회차당첨여부를 확인해야하니!!확인 할 것이 있어야 한다!
					//chkList의 0번째 idx는  check_chapter max이니 50 이고
					// 그러므로 마지막 check_chapter 부터 다시한번 체크함
					chkMap = chkList.get(chk_idx);
					chk_idx++;
					//계단식 
					if(chkMap != null) {
						//i=50 이면
						// winnerMap chapter는 51일테고
						winnerMap = selAllWinList.get(i);
						
						chkArray = CmmUtil.map45ToIntArray(chkMap);
						selAllWinArray = CmmUtil.map6ToIntArray(winnerMap);
						notOverCnt = 0;
						
						for(int j = 0 ; j < 45 ; j++) {
							for(int k = 0 ; k < 6 ; k++ ) {
								if(chkArray[j] == selAllWinArray[k]) {
									notOverCnt++;
								}
							}
							
							if((j+1)%rang_cnt == 0) {
								if(notOverCnt >= inc_cnt) {
									//연속 판단
									//에러식 증가
									//to-do : 히스토리 남기고 세부내용 증가 시켜야 함.
									
									if(Integer.parseInt(String.valueOf(winnerMap.get("chapter")))
																	- Integer.parseInt(String.valueOf(fmlInfoMap.get("err_last_chapter"))) == 1){
										fmlInfoMap.put("cont_cnt", Integer.parseInt(String.valueOf(fmlInfoMap.get("cont_cnt")))+1);
									}
									
									fmlInfoMap.put("err_last_chapter", winnerMap.get("chapter"));
									fmlInfoMap.put("err_cnt", Integer.parseInt(String.valueOf(fmlInfoMap.get("err_cnt")))+1);
									
									if(Integer.parseInt(String.valueOf(fmlInfoMap.get("err_cnt"))) < 50){
										fmlInfoMap.put("err_chapter", winnerMap.get("chapter"));
										fmlDao.insFmlHis(fmlInfoMap);
									}
									if(bln_insNewChapter){
										fmlDao.insNewFml(newFmlMap);
										bln_insNewChapter = false;
									}
									notOverCnt = 0;
									break;
								}
								notOverCnt = 0;
							}
						}
						fmlInfoMap.put("check_chapter", winnerMap.get("chapter"));
					}
				}
				
				fmlInfoMap.put("state", "comp");
				fmlInfoMap.put("avg",Integer.parseInt(String.valueOf(fmlInfoMap.get("check_chapter"))) / (Integer.parseInt(String.valueOf(fmlInfoMap.get("err_cnt")))+1));
				fmlInfoMap.put("point",String.valueOf(fml.fmlMakeMinusPoint(fmlInfoMap,-1)));
				
				fmlDao.udpFmlCheckInfo(fmlInfoMap);
				//logger.info("==============================> Thread End :"+fml_cd+"("+String.valueOf((System.currentTimeMillis() -VerifyCont.VERIFY_ACTIVE_THREAD_MAP.get(fml_cd))/1000)+") / state : "+state+" / use_yn "+use_yn);
				VerifyCont.VERIFY_ACTIVE_THREAD_MAP.remove(fml_cd);
				
		}catch(Exception ex) {
			logger.info("@@@@@@ NOTOVER ERROR3 "+fml_cd+":"+ ex.toString());
		}finally {
			
		}
		
        return rtnInfo;
	}
	
	
	public Map<String,Object> notOver1(Map<String,Object> verifyfmlInfoMap,Map<String, Object> winInfoMap) throws Exception {
		Map<String,Object> rtnInfo = new HashMap<String,Object>();
		String fml_cd = String.valueOf(verifyfmlInfoMap.get("fml_cd"));
		
				
				Map<String,Object> paramMap = new HashMap<String,Object>();
				
				paramMap.put("stair_cd", verifyfmlInfoMap.get("fml_group"));
				paramMap.put("fml_tbl", verifyfmlInfoMap.get("fml_tbl"));
				paramMap.put("check_chapter", winInfoMap.get("chapter"));
				
				Map<String,Object> stairInfoMap = fmlDao.selFmlStairInfo(paramMap);
				
				Map<String,Object> newFmlMap =  null;
				
				int[] stairArray = CmmUtil.map45ToIntArray(stairInfoMap);
				int[] selAllWinArray = CmmUtil.map6ToIntArray(winInfoMap);
				int rang_cnt = Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("rang_cnt")));
				int inc_cnt = Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("inc_cnt")));
				int notOverCnt = 0;
				
				for(int j = 0 ; j < 45 ; j++) {
					
					for(int k = 0 ; k < 6 ; k++ ) {
						if(stairArray[j] == selAllWinArray[k]) {
							notOverCnt++;
						}
					}
						
					if((j+1)%rang_cnt == 0) {
						if(notOverCnt >= inc_cnt) {
							//연속 판단
							//에러식 증가
							//to-do : 히스토리 남기고 세부내용 증가 시켜야 함.
							if(Integer.parseInt(String.valueOf(winInfoMap.get("chapter")))
															- Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("err_last_chapter"))) == 1){
								verifyfmlInfoMap.put("cont_cnt", Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("cont_cnt")))+1);
							}
							
							verifyfmlInfoMap.put("err_last_chapter", winInfoMap.get("chapter"));
							verifyfmlInfoMap.put("err_cnt", Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("err_cnt")))+1);
							
							if(Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("err_cnt"))) < 50){
								verifyfmlInfoMap.put("err_chapter", winInfoMap.get("chapter"));
								fmlDao.insFmlHis(verifyfmlInfoMap);
							}
							if(fmlDao.selNewFml(newFmlMap) == null  //기존에 내용이 없어야 하며
									&& Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("inc_cnt"))) < 7 //포함은 6개이상 될수가 없고 
									&& Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("inc_cnt"))) <= Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("rang_cnt"))) //포함 숫자는 기본 범위를 넘을 수 없다 
									) {
										newFmlMap = new HashMap<String,Object>();
										newFmlMap.putAll(verifyfmlInfoMap);
										newFmlMap.put("fml_cd", verifyfmlInfoMap.get("fml_group")+"_"+verifyfmlInfoMap.get("fml_judg")+"_"+rang_cnt+"_"+(inc_cnt+1));
										newFmlMap.put("inc_cnt", inc_cnt+1);
								
								fmlDao.insNewFml(newFmlMap);
							}
							break;
						}
						notOverCnt = 0;
					}
				}
				
				verifyfmlInfoMap.put("avg",Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("last_check_chapter"))) / (Integer.parseInt(String.valueOf(verifyfmlInfoMap.get("err_cnt")))+1));
				verifyfmlInfoMap.put("point",fml.fmlMakeMinusPoint(verifyfmlInfoMap,-1));
				
				fmlDao.udpFmlCheckInfo(verifyfmlInfoMap);
				//logger.info("==============================> Thread End :"+fml_cd+"("+String.valueOf((System.currentTimeMillis() -VerifyCont.VERIFY_ACTIVE_THREAD_MAP.get(fml_cd))/1000)+") / state : "+state+" / use_yn "+use_yn);
				VerifyCont.VERIFY_ACTIVE_THREAD_MAP.remove(fml_cd);
				
		
		
        return rtnInfo;
	}
		
}

